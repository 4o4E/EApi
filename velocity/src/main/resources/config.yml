# 若设置为true则会在后台输出检查的详细信息
debug: false

server:
  enable: true
  port: 8080

# Nashorn引擎参数设置
# 每次reload后都会重新创建js引擎并应用参数
nashorn_params:
  - "-strict"
  - "--language=es6"

# 数据库配置 可以在脚本中通过 sql(name, sql) 函数调用 返回值为 List<Map<String, Object>>
databases:
  # 数据库名字
  default:
    # clickhouse
    # url: jdbc:clickhouse://localhost:8123/default
    # driver: com.clickhouse.jdbc.ClickHouseDriver
    # username: your-username
    # password: your-password
    # mysql
    url: jdbc:mysql://localhost:3306/your_database
    driver: com.mysql.cj.jdbc.Driver
    username: your_username
    password: your_password
    # 连接池配置
    pool:
      maximumPoolSize: 10
      minimumIdle: 2
      idleTimeout: 600000
      maxLifetime: 1800000
      connectionTimeout: 30000

    # 初始化执行的sql语句
    init:
      - |-
        CREATE TABLE IF NOT EXISTS mc_player_online (
          uuid CHAR(32) NOT NULL COMMENT '玩家UUID',
          name VARCHAR(18) NOT NULL COMMENT '玩家名称',
          server VARCHAR(63) NOT NULL COMMENT '服务器ID',
          login_time BIGINT NOT NULL COMMENT '登录时间',
          logout_time BIGINT COMMENT '登出时间',
          PRIMARY KEY (uuid, login_time)
        ) ENGINE = Innodb DEFAULT CHARSET = utf8mb4 COMMENT = '玩家在线数据表';
      - |-
        CREATE TABLE IF NOT EXISTS mc_logs_test (
          event_time DATETIME COMMENT '事件时间',
          name VARCHAR(50) COMMENT '名称',
          value VARCHAR(255) COMMENT '值'
        ) ENGINE = Innodb DEFAULT CHARSET = utf8mb4 COMMENT = '测试日志表';

# API路由设置
# server 是 velocity 的 proxyServer
# 支持 console.log (以及debug info warn error) 输出调试信息到控制台 前提是打开 debug 选项
# fail(code: number, message: string) 可用来抛出错误响应
# require(fileName: string) 用于加载外部js文件
# sql(dbName: string, sql: string) 用于执行数据库操作 返回值为 List<Map<String, Object>>
# sync<T>(() => T) 用于执行同步操作 并返回结果 应该仅在调用检查调用线程的函数时使用
# request(url: string, method?: string, body?: string) 用于发送HTTP请求 返回值为 Deferred<{status: number, body: string}> 需要用 await(deferred) 接受
# await(deferred) 用来等待异步操作完成
# awaitAll(deferred[]) 用来等待多个异步操作完成
# pathParameters.get 用来获取路径参数
# queryParameters.get 用来获取查询参数
routers:
  - method: GET
    path: /api/server/online
    script: |-
      const servers = Java.from(server.getAllServers());
      JSON.stringify(players.map(e => ({
        "name": e.getServerInfo().getName(),
        "players": e.getPlayersConnected().toArray().map(p => p.getUsername())
      })))
  - method: GET
    path: /api/server/{playerId}/skinName
    script: |-
      const SkinsRestorerProvider = Java.type('net.skinsrestorer.api.SkinsRestorerProvider');
      const UUID = Java.type('java.util.UUID');
      const Base64 = Java.type('java.util.Base64');
      const String = Java.type('java.lang.String');
      const StandardCharsets = Java.type('java.nio.charset.StandardCharsets');
      
      const result = {};
      
      const playerName = pathParameters.get("playerId");
      var targetUUID = null;
      
      var playerOpt = server.getPlayer(playerName);
      if (playerOpt.isPresent()) {
        targetUUID = playerOpt.get().getUniqueId();
      }
      
      if (targetUUID === null) {
        var offlineStr = "OfflinePlayer:" + playerName;
        targetUUID = UUID.nameUUIDFromBytes(offlineStr.getBytes(StandardCharsets.UTF_8));
      }
      
      if (!targetUUID) fail(400, "Cannot determine UUID for player: " + playerName);
      
      const srApi = SkinsRestorerProvider.get();
      
      const playerStorage = srApi.getPlayerStorage();
      if (!playerStorage) fail(500, 'playerStorage undefined');
      var userSkinOpt = playerStorage.getSkinOfPlayer(targetUUID);
      
      if (!userSkinOpt.isPresent()) fail(200, playerName);
      
      const userSkin = userSkinOpt.get()
      
      const value = new String(Base64.getDecoder().decode(userSkin.getValue()), StandardCharsets.UTF_8)
      const profile = JSON.parse(value)
      // console.log('profile', profile)
      
      profile.profileName