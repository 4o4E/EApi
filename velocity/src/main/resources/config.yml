# 若设置为true则会在后台输出检查的详细信息
debug: false

server:
  enable: true
  port: 8080

# Nashorn引擎参数设置
# 每次reload后都会重新创建js引擎并应用参数
nashorn_params:
  - "-strict"
  - "--language=es6"

# 数据库配置 可以在脚本中通过 sql(name, sql) 函数调用 返回值为 List<Map<String, Object>>
databases:
  # 数据库名字
  default:
    # clickhouse
    # url: jdbc:clickhouse://localhost:8123/default
    # driver: com.clickhouse.jdbc.ClickHouseDriver
    # username: your-username
    # password: your-password
    # mysql
    url: jdbc:mysql://localhost:3306/your_database
    driver: com.mysql.cj.jdbc.Driver
    username: your_username
    password: your_password
    # 连接池配置
    pool:
      maximumPoolSize: 10
      minimumIdle: 2
      idleTimeout: 600000
      maxLifetime: 1800000
      connectionTimeout: 30000

    # 初始化执行的sql语句
    init:
      - |-
        CREATE TABLE IF NOT EXISTS mc_player_online (
          uuid CHAR(32) NOT NULL COMMENT '玩家UUID',
          name VARCHAR(18) NOT NULL COMMENT '玩家名称',
          login_time BIGINT NOT NULL COMMENT '登录时间',
          logout_time BIGINT COMMENT '登出时间',
          PRIMARY KEY (uuid, login_time)
        ) ENGINE = Innodb DEFAULT CHARSET = utf8mb4 COMMENT = '玩家在线数据表';
      - |-
        CREATE TABLE IF NOT EXISTS mc_logs_test (
          event_time DATETIME COMMENT '事件时间',
          name VARCHAR(50) COMMENT '名称',
          value VARCHAR(255) COMMENT '值'
        ) ENGINE = Innodb DEFAULT CHARSET = utf8mb4 COMMENT = '测试日志表';

# API路由设置
# server 是 velocity 的 proxyServer
# 支持 console.log (以及debug info warn error) 输出调试信息到控制台 前提是打开 debug 选项
# fail(code: number, message: string) 可用来抛出错误响应
# require(fileName: string) 用于加载外部js文件
# pathParameters.get 用来获取路径参数
# queryParameters.get 用来获取查询参数
routers:
  - method: GET
    path: /api/server/online
    script: |-
      const servers = Java.from(server.getAllServers());
      JSON.stringify(players.map(e => ({
        "name": e.getServerInfo().getName(),
        "players": e.getPlayersConnected().toArray().map(p => p.getUsername())
      })))
  - method: GET
    path: /api/server/{playerId}/skin
    script: |-
      var SkinsRestorerProvider = Java.type('net.skinsrestorer.api.SkinsRestorerProvider');
      var UUID = Java.type('java.util.UUID');
      var StandardCharsets = Java.type('java.nio.charset.StandardCharsets');
      
      var result = {};
      
      var playerName = pathParameters.get("playerId");
      var targetUUID = null;
  
      // 1. 尝试获取在线玩家 (最准确，如果在线直接用)
      if (typeof server !== 'undefined') {
          var playerOpt = server.getPlayer(playerName);
          if (playerOpt.isPresent()) {
              targetUUID = playerOpt.get().getUniqueId();
          }
      }
  
      // 2. 如果玩家离线，且服务器是离线模式，手动计算 Offline UUID
      // 算法标准：UUID.nameUUIDFromBytes("OfflinePlayer:" + name)
      if (targetUUID === null && playerName) {
          var offlineStr = "OfflinePlayer:" + playerName;
          targetUUID = UUID.nameUUIDFromBytes(offlineStr.getBytes(StandardCharsets.UTF_8));
      }
  
      if (!targetUUID) throw new Error("Cannot determine UUID for player: " + playerName);
  
      // 3. 获取 SkinsRestorer API
      var srApi = SkinsRestorerProvider.get();
      
      // 4. 查询存储 (查询该 UUID 当前设置了什么皮肤)
      // getPlayerStorage() 管理玩家的数据绑定
      var userSkinOpt = srApi.getPlayerStorage().getSkinOfUser(targetUUID);

      if (!userSkinOpt.isPresent()) throw new Error("No skin data found for UUID: " + targetUUID.toString());
      
      JSON.stringify(userSkinOpt.get());